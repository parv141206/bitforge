"use client";
import { DirectModeInstructions } from "@/constants/DirectModeInstructions";
import { ImmediateModeInstructions } from "@/constants/ImmediateModeInstructions";
import { ImpliedModeInstructions } from "@/constants/ImpliedModeInstructions";
import { IndirectModeInstructions } from "@/constants/IndirectModeInstructions";
import React, { createContext, useContext, useState } from "react";

export interface Instruction {
  opcode: string;
  mnemonic: string;
  description: string;
  bytes: number;
  operands: string[];
}

const InstructionContext = createContext<any>(null);

export const InstructionProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const [instructions] = useState<Instruction[]>([
    ...ImmediateModeInstructions,
    ...DirectModeInstructions,
    ...IndirectModeInstructions,
    ...ImpliedModeInstructions,
  ]);

  const [selectedInstructions, setSelectedInstructions] = useState<
    Instruction[]
  >([]);

  // Store operand values for each selected instruction
  const [operandsValues, setOperandsValues] = useState<{
    [key: string]: { [key: string]: string };
  }>({});

  const selectInstruction = (mnemonic: string) => {
    const instruction = instructions.find((inst) => inst.mnemonic === mnemonic);
    if (instruction) {
      setSelectedInstructions((prev) => {
        // Check if the instruction is already selected
        const exists = prev.some((inst) => inst.mnemonic === mnemonic);
        if (exists) {
          // Remove it if already selected
          return prev.filter((inst) => inst.mnemonic !== mnemonic);
        } else {
          // Add it if not selected
          return [...prev, instruction];
        }
      });
      // Initialize operand values for the new instruction
      setOperandsValues((prev) => ({
        ...prev,
        [mnemonic]: {},
      }));
    }
  };

  const updateOperandValue = (
    mnemonic: string,
    operand: string,
    value: string
  ) => {
    setOperandsValues((prev) => ({
      ...prev,
      [mnemonic]: {
        ...prev[mnemonic],
        [operand]: value,
      },
    }));
  };

  const generateDescription = () => {
    return selectedInstructions.map((instruction) => {
      let description = instruction.description;
      for (const operand of instruction.operands) {
        description = description.replace(
          `{${operand}}`,
          operandsValues[instruction.mnemonic]?.[operand] || ""
        );
      }
      return description;
    });
  };

  return (
    <InstructionContext.Provider
      value={{
        instructions,
        selectedInstructions,
        selectInstruction,
        updateOperandValue,
        generateDescription,
      }}
    >
      {children}
    </InstructionContext.Provider>
  );
};

export const useInstructions = () => useContext(InstructionContext);
